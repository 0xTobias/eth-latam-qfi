# Values for the status of the QFI.
enum Stage {
  NotInitialized
  WaitingForSignupsAndTopups
  VotingPeriodOpen
  WaitingForFinalization
  Finalized
  Cancelled
}

# Values for the RecipientRegistry requests.
enum RequestType {
  Registration
  Removal
}

# QFI Core entity.
type QFI @entity {
    id: ID!

    # Main fields.
    coordinator: Coordinator! # ok
    currentStage: Stage! # Enum. # ok
    voiceCreditFactor: BigInt! # ok
    nextGrantRoundId: BigInt! # ok
    contributorCount: BigInt! # ok
    isStateAqMerged: Boolean! # ok

    # Inherited from MACI.
    stateTreeDepth: Int! # ok
    numSignUps: BigInt! # ok
    isInitialized: Boolean! # ok
    signUpTimestamp: BigInt! # ok
    # Useful smart contracts addresses.
    signUpGatekeeperAddress: Bytes! # ok
    initialVoiceCreditProxyAddress: Bytes! # ok
    vkRegistryAddress: Bytes! # ok
    pollFactoryAddress: Bytes! # ok
    messageAqFactoryPollAddress: Bytes! # ok
    stateAqAddress: Bytes! # ok

    nativeERC20TokenAddress: Bytes! # ok
    messageAqFactoryGrantRoundAddress: Bytes! # ok
    grantRoundFactoryAddress: Bytes! # ok
    pollProcessorAndTallyerAddress: Bytes! # ok

    # TODO: Are the info from PPT contract necessary? How we can retrieve these?
    # From PPT contract.
    # verifierAddress: Bytes!
    # sbCommitment: BigInt!
    # currentMessageBatchIndex: BigInt!
    # processingComplete: Boolean!
    # numBatchesProcessed: BigInt!
    # tallyCommitment: BigInt!
    # tallyBatchNum: BigInt!

    # Links.
    recipientRegistry: RecipientRegistry! # ok
    currentGrantRound: GrantRound! # ok

    # Reverse Lookups.
    grantRounds: [GrantRound!] @derivedFrom(field: "qfi") # ok
    # Specifically, those Polls are GrantRounds (polls[pollId] = g, where g is a GrantRound).
    polls: [GrantRound!] @derivedFrom(field: "qfi") # ok
    
    fundingSources: [FundingSource!] @derivedFrom(field: "qfi") # ok

    createdAt: String
    lastUpdatedAt: String
}

# Represents a PublicKey used during the subscription and or forwarding of a message. 
type PublicKey @entity {
    id: ID!

    # Main fields.
    x: BigInt! # ok
    y: BigInt! # ok

    # Associated voting info.
    stateIndex: BigInt! # ok
    voiceCreditBalance: BigInt! # ok
    
    # Links.
    grantRound: GrantRound # Can be present if the PublicKey is used in addition to send a message.

    # Reverse Lookup for the messages signed w/ this public key.
    messages: [Message!] @derivedFrom(field: "publicKey") # ok

    timestamp: BigInt! # ok
}

type Message @entity {
    id: ID!
    
    data: [BigInt!] # ok

    # Links.
    publicKey: PublicKey! # ok
    grantRound: GrantRound! # ok
    
    timestamp: BigInt! # ok
}

# nb. Mainly based on OptimisticRecipientRegistry implementation.
type RecipientRegistry @entity {
    id: ID!

    # Main fields.
    grantRoundFactoryAddress: Bytes! # ok
    baseDeposit: BigInt! # ok
    challengePeriodDuration: BigInt! # ok
    controller: Bytes! # ok
    maxRecipients: BigInt! # ok

    # Link.
    grantRound: GrantRound! # ok

    # Reverse Lookup for the recipients registered in this registry.
    recipients: [Recipient!] @derivedFrom(field: "recipientRegistry")

    createdAt: String
    lastUpdatedAt: String 
}

# nb. Mainly based on OptimisticRecipientRegistry implementation.
type Recipient @entity {
    id: ID!

    # Main fields.
    address: Bytes! # ok
    metadata: String! # ok
    requestType: RequestType! # Enum. # ok
    requesterAddress: Bytes! # ok
    submissionTime: BigInt! # ok
    deposit: BigInt! # ok
    addedAt: BigInt! # ok
    removedAt: BigInt! # ok
    voteOptionIndex: BigInt # ok
    rejected: Boolean! # ok
    # Tx hash mirror.
    requestResolvedHash: Bytes # ok
    requestSubmittedHash: Bytes # ok

    # Links.
    grantRounds: [GrantRound!] # The same recipient can be part of multiple Grant Rounds. # ok
    recipientRegistry: RecipientRegistry! # ok

    # Reverse Lookup of the claimed funds sent to this recipient.
    funds: [Funds!] @derivedFrom(field: "recipient") # ok

    createdAt: String
    lastUpdatedAt: String
}

type GrantRound @entity {
    id: ID!

    # Main fields (also from Poll).
    # Max values.
    maxMessages: BigInt! # ok
    maxVoteOptions: BigInt! # ok
    # Tree depths.
    intStateTreeDepth: BigInt! # ok
    messageTreeSubDepth: BigInt! # ok
    messageTreeDepth: BigInt! # ok
    voteOptionTreeDepth: BigInt! # ok
    # Batch sizes.
    tallyBatchSize: BigInt! # ok
    messageBatchSize: BigInt! # ok
    # Time and duration.
    duration: BigInt! # ok
    deployTimestamp: BigInt! # Grant Round start time. # ok
    voiceCreditFactor: BigInt! # ok
    # Status.
    isCancelled: Boolean! # ok
    isMessageAqMerged: Boolean!
    isFinalized: Boolean! # ok
    stateAqMerged: Boolean! # ok
    # State Ballot commitment.
    currentSbCommitment: BigInt! # Can be useful for on-chain verification.
    mergedStateRoot: BigInt! # ok
    tallyHash: String! # ok
    # Total amounts spent, votes, and matching funds.
    totalSpent: BigInt! # ok
    totalVotes: BigInt! # ok
    matchingPoolSize: BigInt! # ok
    # Should we have to track ext contracts addresses?
    # messageAqAddress: Bytes!
    # vkRegistryAddress: Bytes!

    # Links.
    qfi: QFI! # ok
    recipientRegistry: RecipientRegistry! # ok
    # Duplicated from QFI.
    # nativeERC20Token: Token!
    coordinator: Coordinator! # ok

    # Reverse Lookups.
    # Messages related to this grant round.
    messages: [Message!] @derivedFrom(field: "grantRound")
    # Recipients related to this grant round.
    recipients: [Recipient!] @derivedFrom(field: "grantRounds") # ok
    # Who has contributed to the grant round.
    contributors: [Contributor!] @derivedFrom(field: "grantRounds")
    # The contributions to the grant round.
    contributions: [Contribution!] @derivedFrom(field: "grantRound")
    # Who has quadratically voted (w/ VCs) in the grant round.
    votes: [Vote!] @derivedFrom(field: "grantRound")
    
    createdAt: String
    lastUpdatedAt: String
}

# The coordinator is quite empty entity but can be useful to regroup some information
# as the address and encPubKey w/ one link on other entities.
type Coordinator @entity {
    id: ID!

    # Main fields.
    address: Bytes! # ok
    publicKey: String! # ok

    # Links.
    qfi: QFI! # ok
    grantRounds: [GrantRound!] # ok
}

# A contributor who has sent tokens to the matching pool in exchange of VCs.
type Contributor @entity {
    id: ID!
    
    # Main fields.
    address: Bytes! # Eth EOA. # ok
    voiceCredits: BigInt! # ok
    isRegistered: Boolean! # ok

    # Link.
    grantRounds: [GrantRound!] # Different GrantRounds where it took part. # ok

    # Reverse lookups.
    contributions: [Contribution!] @derivedFrom(field: "contributor") # ok
    votes: [Vote!] @derivedFrom(field: "contributor") # ok
    
    createdAt: String
    lastUpdatedAt: String
}

type Contribution @entity {
    id: ID!

    # Main fields.
    amount: BigInt! # ok
    voiceCredits: BigInt! # ok

    # Links.
    contributor: Contributor! # ok
    grantRound: GrantRound! # ok

    createdAt: String
    lastUpdatedAt: String
}

# The amount of funds claimed/donated from the matching fund to 
# each recipient based on the result of the (tally) voting process.
type Funds @entity {
    id: ID!

    # Main fields.
    amount: BigInt # ok
    voteOptionIndex: BigInt # ok

    # Links
    recipient: Recipient # ok
    grantRound: GrantRound # ok

    createdAt: String # ok
}

# This entity is stored when a contributor cast a vote (publish a message) 
# for the first time in a grant round.
type Vote @entity {
    id: ID!

    # Links.
    contributor: Contributor! # ok
    grantRound: GrantRound! # ok
}

type FundingSource @entity {
    id: ID!

    qfi: QFI! # ok
    address: Bytes! # ok
    isActive: Boolean! # False when removed, otherwise true. # ok

    createdAt: String!
    lastUpdatedAt: String!
}